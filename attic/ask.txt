I want to be able to define C protothread functions and related structures
by using C macros.  The core of this uses C preprocessor x-macros.  X-macro lists are defined for
protothread arguments and variables.   A type is defined for the result of the
protothread.  These are used to generate supporting structures and functions.  The file `protothread.h`
contains the generic definitions used for protothreads.  The file `protothread.c` contains
generic function definitions supporting protothreads.  The file `protothread_gen.h` contains definitions that generate
the specific structs and functions that are needed to implement the specific protothread.

```c

#include <protothread.h>

#define PT_ARG_LIST \
    PT_ARG_ENTRY(int, start_val) \
    PT_ARG_ENTRY(int, end_val)

#define PL_VAR_LIST \
    PT_VAR_ENTRY(int, current_val)

#include <protothread_gen.h>

/* generate the structs and function prototypes needed. */
PT_GENERATE_DEFS(my_int_generator, int, PT_ARG_LIST, PT_VAR_LIST)

/* generate the function header needed for function */
PT_GENERATE_FUNC(my_int_generator)
    for(vars->current_val = args->start_val; vars->current_val <= args->end_val; ++vars->current_val) {
        pt_yield(vars->current_val);
    }

    pt_exit(PT_DONE);
PT_FUNC_END

/* generate the function header for the destructor */
PT_GENERATE_DESTRUCTOR(my_int_generator) { printf("Nothing to do here.\n");}


int main(void) {
    my_int_generator_pt_t *my_int_generator = my_int_generator_create(42, "hello", 3.14);

    if(!my_int_generator) {
        printf("Something went wrong!  We could not allocate memory for the generator!\n");
        return -1;
    }

    do {
        /* this is a macro that casts the my_int_generator pointer to a pt_t pointer and then calls a generic function */
        pt_resume(my_int_generator);

        printf("Got value %d\n", pt_result(my_int_generator));

        /* pt_status is a macro that casts the my_int_generator pointer to a pt_t pointer and then gets the status */
    } while(pt_status(my_int_generator) == PT_RUNNING);

    /* joining will terminate the protothread */
    pt_join(my_int_generator);

    return 0;
}
```

The macros should generate something like the following:

```c

/* this is defined in protothreads.h */
typedef struct pt_t {
    int step; /* used in protothread switch/case implementation */
    int status; /* status of protothread, PT_RUNNING, PT_DONE */

    int (*pt_runner_wrapper){struct pt_t *pt};
    void (*pt_destructor_wrapper)(struct pt_t *pt);
} pt_t;

/* defined by macros in the file protothread_gen.h */
typedef struct {
    int start_val;
    int end_val;
} my_int_generator_args_t;

/* defined by macros in the file protothread_gen.h */
typedef struct {
    int current_val;
} my_int_generator_vars_t;


/* defined by macros in the file protothread_gen.h */
typedef struct {
    struct pt_t __pt__; /* used by protothreads infrastructure */

    int result;

    my_int_generator_args_t args;
    my_int_generator_vars_t vars;

} my_int_generator_pt_t;

/* defined by macros in the file protothread_gen.h */
int my_int_generator_runner_wrapper(pt_t *pt);
int my_int_generator_runner(my_int_generator_pt_t *__pt__, my_int_generator_args_t *args, my_int_generator_vars_t *vars, int *result);
void my_int_generator_destructor_wapper(pt_t *pt);
void my_int_generator_destructor(my_int_generator_args_t *args, my_int_generator_vars_t *vars, int *result);


my_int_generator_pt_t *my_int_generator_create(int start_val, int end_val) {
    my_int_generator_pt_t *pt = (my_int_generator_pt_t *)malloc(sizeof(my_int_generator_pt_t));

    if(!pt) {
        return NULL;
    }

    memset(pt, 0, sizeof(my_int_generator_pt_t));

    /* sets the runner and destructor, set the step to PT_INIT and the state to PT_RUNNING */
    pt_init(pt, my_int_generator_runner_wrapper, my_int_generator_destructor);

    pt->args.start_val = start_val;
    pt->args.end_val = end_val;

    return pt;
}

int my_int_generator_runner_wrapper(pt_t *pt) {
    my_int_generator_pt_t *__pt__ = (my_int_generator_pt_t *)pt;
    return my_int_generator_runner(__pt__, &__pt__->args, &__pt__->vars, &__pt__->result);
}

void my_int_generator_destructor_wapper(pt_t *pt) {
    my_int_generator_pt_t *__pt__ = (my_int_generator_pt_t *)pt;
    my_int_generator_destructor(&__pt__->args, &__pt__->vars, &__pt__->result);
}

/* below are functions that are only partially generated by the macros */

int my_int_generator_runner(pt_t *__pt__, my_int_generator_args_t *args, my_int_generator_vars_t *vars, my_int_generator_result_t *result) {
    /* generated */
    my_int_generator_args_t *args = (my_int_generator_args_t *)pt->args;
    my_int_generator_vars_t *vars = (my_int_generator_vars_t *)pt->vars;
    int *result = (int *)pt->result;

    switch(__pt__->step) {
        case PT_START:

        for(vars->current_val = args->start_val; vars->current_val <= args->end_val; ++vars->current_val) {
            pt_yield(vars->current_val);
        }

        pt_exit(PT_DONE);

        pt->status = PT_DONE;

        break;

        ... other steps as needed ...

    default:
        /* error handling from protothread.h definitions */
        pt->status = PT_ERROR;
        break;
    }
}


void my_int_generator_destructor(my_int_generator_args_t *args, my_int_generator_vars_t *vars, int *result) {
    /* do anything needed to release resources from my_int_generator protothread */

    /* free things from args and vars if needed */

    printf("Nothing to do here.\n");

    /* the protothread infrastructure frees the memory for the protothread struct. */
}


int main(void) {
    my_int_generator_pt_t *my_int_generator = my_int_generator_create(42, "hello", 3.14);

    if(!my_int_generator) {
        printf("Something went wrong!  We could not allocate memory for the generator!\n");
        return -1;
    }

    do {
        /* could be a macro or an inline function or a regular function.  A macro is probably easier */
        pt_resume(my_int_generator);

        printf("Got value %d\n", pt_result(my_int_generator));

        /* pt_status() could be a macro */
    } while(pt_status(my_int_generator) == PT_RUNNING);

    /* joining will terminate the protothread */
    /* probably a function */
    pt_join(my_int_generator);

    return 0;
}

```

Generate the code required in the following files:

`protothread.h` - generic protothread definitions possibly include pt_yield, pt_status, etc.

`protothread.c` - generic protothread function definitions including pt_resume and pt_exit etc. This file is not needed if
    all functionality can be done via macros in `protothread.h`.

`protothread_gen.h` - macros to help generate specific protothread structs, wrapper functions, create function, partial supporting
    This file is included for use with X-macro-like definitions for the protothread arguments and variables and return type.

The existing versions of these files are not correct.  Generate the use of x-macro replacement carefully.

Suggest changes that make implementation feasible and/or easier to use.
